<?php namespace ProcessWire;

use RRule\RRule;

/**
 * FieldtypeEvents
 *
 * Fieldtype for a field that stores events each with a date and title
 *
 * This is an example of creating your own FieldtypeMulti to represent a spreadsheet type table of information.
 *
 */

class FieldtypeRecurringDates extends FieldtypeMulti {

    public static function getModuleInfo() {
        return array(
            'title' => 'Recurring Dates',
            'version' => 001,
            'summary' => 'Field that stores a table of events for a page.',
            'icon' => 'calendar-o',
            'installs' => 'InputfieldRecurringDates',
        );
    }
    const EXTRAS_TABLE_NAME_SUFFIX =  '_extras';
    /**
     * Construct the Fieldtype, make sure all dependencies are in place
     *
     */

    public function __construct() {
        $this->set('usePagination', true);
        $this->set('useOrderByCols', true);
        require_once(__DIR__ . '/RecurringDatesSettings.php');
        require_once(__DIR__ . '/RecurringDate.php');
        require_once(__DIR__ . '/Occurrence.php');
        require_once(__DIR__ . '/OccurrenceArray.php');
        parent::__construct();
    }

    public function init(){

        $this->addHook('/fieldtype-recurring-dates/get-dates/', function($event){
            if(!$event->user->isLoggedin()) return;
            $rrule = json_decode($event->input->get->data, true);
            $this->getRruleOcurrences();
            //$page_id = $event->input->get->int('id');
        });

        $this->addHookAfter('Fields::added', $this, 'hookAfterFieldAdded');
        $this->addHookAfter('Fields::deleted', $this, 'hookAfterFieldDeleted');

    }

    public function ready(){
        bd($this);
    }

    /**
     * Adds the rrule database table
     *
     * @return void
     *
     */
    public function hookAfterFieldAdded($event){
        $item = $event->arguments(0);
        if($item->type->name == $this->name) {
            $table_name = $this->getExtrasTableName($item);
            $create_rrules_table = "";
            $create_rrules_table .=
              "DROP TABLE IF EXISTS $table_name;" .
              "CREATE TABLE $table_name (" .
              "pages_id INT UNSIGNED NOT NULL, " .
              "rrule MEDIUMTEXT NOT NULL," .
              "settings MEDIUMTEXT NOT NULL," .
              "PRIMARY KEY (`pages_id`)," .
              "UNIQUE KEY (`pages_id`)".
              ")";
            try {
                $query = $this->database->prepare($create_rrules_table);
                $query->execute();
            } catch (\Exception $e) {
                $this->database->error($e->getMessage());
            }
        }
    }

    public function hookAfterFieldDeleted($event){
        $item = $event->arguments(0);
        if($item->type->name == $this->name) {
            $table_name = $this->getExtrasTableName($item);
            $create_rrules_table = "";
            $create_rrules_table .= "DROP TABLE IF EXISTS $table_name;";
            try {
                $query = $this->database->prepare($create_rrules_table);
                $query->execute();
            } catch (\Exception $e) {
                $this->database->error($e->getMessage());
            }
        }
    }



    public function getRruleOCurrences($value){
        $rrule = new RRule($value);
        return $rrule;
    }

    /**
     * Return the database schema that defines an Ocurrence
     *
     * @param Field $field
     * @return array
     *
     */
    public function getDatabaseSchema(Field $field) {
        $schema = parent::getDatabaseSchema($field);
        $schema['id'] = 'INT UNSIGNED NOT NULL AUTO_INCREMENT';
        $schema['keys']['primary'] = 'PRIMARY KEY (id)';
        $schema['data'] = 'datetime NOT NULL';
        $schema['excluded'] = 'tinyint NOT NULL';
        $schema['keys']['data'] = 'KEY data (data)';
        return $schema;
    }


    /**
     * Return the Inputfield used to collect input for a field of this type
     *
     * @param Page $page
     * @param Field $field
     * @return Inputfield|InputfieldRecurringDates
     *
     */
    public function getInputfield(Page $page, Field $field) {
        $inputfield = $this->modules->get('InputfieldRecurringDates'); /** @var InputfieldRecurringDates $inputfield */
        return $inputfield;
    }

    /**
     * Return a blank ready-to-populate value
     *
     * @param Page $page
     * @param Field $field
     * @return RecurringDate
     *
     */
    public function getBlankValue(Page $page, Field $field) {
        return new RecurringDate();
        //return new OccurrenceArray();
    }


    /**
     * Given a value, make it clean and of the correct type for storage within a Page
     *
     * @param Page $page
     * @param Field $field
     * @param EventArray $value
     * @return mixed
     *
     */
    public function sanitizeValue(Page $page, Field $field, $value) {
        // if given an invalid value, return a valid blank value
        return $value;
    }

    /*public function ___savePageField(Page $page, Field $field) {
        parent::___savePageField($page, $field);

    }*/
    protected function getRecurringDatesTable()
    {
        $field_name = $this->getAttribute('name');
        return "field_{$field_name}_dates";
    }



    /**
     * Given a raw value from DB (arrays), return the value as it would appear in a Page object (EventArray)
     *
     * @param Page $page
     * @param Field $field
     * @param RecurringDate $value
     //* @return EventArray
     *
     */
    public function ___wakeupValue(Page $page, Field $field, $value) {

        $recurring_date = $this->getBlankValue($page, $field);
        //bd($recurring_date->settings->getArray());
        $recurring_date->settings = json_encode($recurring_date->settings, true);
        //bd($recurring_date->settings);
        if(empty($value) || !is_array($value)) return $recurring_date;
        $settings = $this->getSettings($page, $field);
        $recurring_date->rrule = $settings->rrule;

        $recurring_date->settings = $settings->settings;

        foreach($value as $v) {
            $occurrence = new Occurrence();
            $occurrence->date = (new \DateTime($v['data']));
            $occurrence->excluded = $v['excluded'] ? true : false;
            $occurrence->resetTrackChanges();
            $recurring_date->occurrences->add($occurrence);
            //$occurrences->add($occurrence);
        }

        // tell it to start tracking changes from this point forward
        $recurring_date->occurrences->resetTrackChanges();
        bd($recurring_date,  'wakupValue');
        return $recurring_date;
    }

    /**
     * Given an EventArray value, convert the value back to an array for storage in DB
     *
     * @param Page $page
     * @param Field $field
     * @param array $value
     * @return array
     *
     */
    public function ___sleepValue(Page $page, Field $field, $value) {

        $sleepValue = array();

        if(!$value instanceof RecurringDate) return $sleepValue;
        // make the events sort by date ascending
        $value->occurrences->sort('date');

        bd($value->settings);

        $this->saveSettings($page, $field, $value);

        // convert each Event to an array within sleepValue
        foreach($value->occurrences as $occurrence) {
            // if no date specified then skip it
            if(!$occurrence->date) continue;

            // if event is formatted, fail, we we don't want entity-encoded text in DB
            if($occurrence->formatted) throw new WireException('Formatted events cannot be saved');
            $sleepValue[] = array(
              'data' => $occurrence->date, // note: 'date' is becoming 'data' (with an 'a')
              'excluded' => $occurrence->excluded
            );
        }

        return $sleepValue;
    }

    /**
     * Format a value for front-end output
     *
     * This is the same as a regular value except that it is a cloned copy with
     * the “title” subfields entity encoded for output in markup.
     *
     * @param Page $page
     * @param Field $field
     * @param EventArray $value
     * @return EventArray
     *
     */
    public function ___formatValue(Page $page, Field $field, $value) {
        // make a new copy with formatted events (i.e. entity-encoded titles)
        /*foreach($value->ocurrences as $i => $ocurrence){
            $ocurrence->formatDate('U');
        }*/
        return $value;
    }

    /**
     * Render a markup string of the value (optional for Fieldtypes to implement)
     *
     * @param Page $page
     * @param Field $field
     * @param EventArray $value
     * @param string $property Property to render or omit for all
     * @return string|MarkupFieldtype
     *
     */

    public function ___markupValue(Page $page, Field $field, $value = null, $property = '') {
        if(!$value instanceof RecurrentD) $value = $page->get($field->name);
        if(!$value instanceof EventArray || !$value->count()) return '';
        $a = [];
        foreach($value as $event) {
            if($property) {
                $a[] = $this->sanitizer->entities1($event->get($property));
            } else {
                $a[] = $this->sanitizer->entities1("$event->date");
            }
        }
        return "<ul><li>" . implode("</li><li>", $a) . "</li></ul>";
    }

    public function getMonths(){
        $months = [];
        for ($m=1; $m<=12; $m++) {
            $months[] = date('F', mktime(0,0,0,$m, 1, date('Y')));
        }
        //bd($months);
        return $months;
    }

    /**
     * Method called when the field is database-queried from a $pages->find() selector
     *
     * @param DatabaseQuerySelect|PageFinderDatabaseQuerySelect
     * @param string $table
     * @param string $subfield
     * @param string $operator
     * @param string $value
     * @return PageFinderDatabaseQuerySelect
     *
     */
    /*
    public function getMatchQuery($query, $table, $subfield, $operator, $value) {

        if($subfield == 'date') {
            // If searching 'date' then assume our default (data) field
            $subfield = 'data';
        }

        if($subfield === 'data') {
            // if searching data, make sure it is in the correct 'date' format
            $value = wireDate('Y-m-d', $value);

        } else if($subfield === 'title') {
            // use fulltext search features when searching title
            $finder = new DatabaseQuerySelectFulltext($query);
            $finder->match($table, $subfield, $operator, $value);
            return $query;
        }

        return parent::getMatchQuery($query, $table, $subfield, $operator, $value);
    }
    */

    /**
     * Return array with information about what properties and operators can be used with this field
     *
     * This is what is used when finding pages like with Lister/ListerPro, etc.
     * ProcessWire’s default generally gets this right so we often don’t have to implement this method.
     * In this case, we are just having it show the correct label for “Date”.
     *
     * @param Field $field
     * @param array $data Array of extra data, when/if needed
     * @return array
     *
     */
    /*public function ___getSelectorInfo(Field $field, array $data = array()) {
        $info = parent::___getSelectorInfo($field, $data);
        $info['subfields']['data']['label'] = $this->_('Date');
        return $info;
    }*/

    public function ___loadPageField(Page $page, Field $field)
    {   //bd($field);
        //$field->set('paginationLimit', 2);
        $input = $this->wire()->input;
        $value =  parent::___loadPageField($page, $field); // TODO: Change the autogenerated stub
        return $value;
    }

    /**
     * Saves rrule string when field is saved.
     *
     * @param Page $page
     * @param Field $field
     * @param string $rule
     * @return void
     */
    protected function saveSettings(Page $page, Field $field, RecurringDate $rdate){
        $sql = "INSERT INTO {$this->getExtrasTableName($field)} (pages_id, rrule, settings) VALUES(:pages_id, :rrule, :settings) ON DUPLICATE KEY UPDATE pages_id=:pages_id, rrule=:rrule, settings=:settings";
        /** @var \PDOStatement $pdo */
        $pdo = $this->database->prepare($sql);
        $pdo->bindValue(':pages_id', $page->id);
        //bd($this->serializeSettings());
        $pdo->bindValue(':rrule', $rdate->rrule);
        bd((string)$rdate->settings);
        $pdo->bindValue(':settings', (string) $rdate->settings);
        bd($pdo->queryString);
        $pdo->execute();
    }

    /**
     * Get rrule when field. Used on wareup value.
     *
     * @param Page $page
     * @param Field $field
     * @return string
     */
    protected function getSettings(Page $page, Field $field){
        $sql = "SELECT rrule, settings FROM {$this->getExtrasTableName($field)} WHERE pages_id=:pages_id";
        $pdo = $this->database->prepare($sql);
        $pdo->bindValue(':pages_id', $page->id);
        $pdo->execute();
        return $pdo->fetch(\PDO::FETCH_OBJ);
    }

    public function getExtrasTableName($field){
        return $field->getTable() . self::EXTRAS_TABLE_NAME_SUFFIX;
    }

}
