<?php namespace ProcessWire;

use RRule\RRule;

/**
 * FieldtypeEvents
 *
 * Fieldtype for a field that stores events each with a date and title
 *
 * This is an example of creating your own FieldtypeMulti to represent a spreadsheet type table of information.
 *
 */

class FieldtypeRecurringDates extends FieldtypeMulti {

    public static function getModuleInfo() {
        return array(
            'title' => 'Recurring Dates',
            'version' => 001,
            'summary' => 'Field that stores a table of events for a page.',
            'icon' => 'calendar-o',
            'installs' => 'InputfieldRecurringDates',
        );
    }

    /**
     * Construct the Fieldtype, make sure all dependencies are in place
     *
     */
    public function __construct() {
        //$this->set('usePagination', true);
        //$this->set('useOrderByCols', true);
        require_once(__DIR__ . '/Occurrence.php');
        require_once(__DIR__ . '/OccurrenceArray.php');
        parent::__construct();
    }

    public function init(){

        $this->addHook('/fieldtype-recurring-dates/get-dates/', function($event){
            if(!$event->user->isLoggedin()) return;
            $rrule = json_decode($event->input->get->data, true);
            $this->getRruleOcurrences();
            //$page_id = $event->input->get->int('id');
        });
    }

    public function ready(){
        bd($this);
    }

    public function getRruleOCurrences($value){
        $rrule = new RRule($value);
        return $rrule;
    }

    /**
     * Return the database schema that defines an Event
     *
     * @param Field $field
     * @return array
     *
     */
    public function getDatabaseSchema(Field $field) {
        $schema = parent::getDatabaseSchema($field);
        /*$schema['id'] = 'INT UNSIGNED NOT NULL AUTO_INCREMENT';
        $schema['keys']['primary'] = 'PRIMARY KEY (id)';*/
        $schema['data'] = 'datetime NOT NULL';
        $schema['excluded'] = 'tinyint NOT NULL';
        $schema['keys']['data'] = 'KEY data (data)';
        return $schema;
    }


    /**
     * Return the Inputfield used to collect input for a field of this type
     *
     * @param Page $page
     * @param Field $field
     * @return Inputfield|InputfieldEvents
     *
     */
    public function getInputfield(Page $page, Field $field) {
        $inputfield = $this->modules->get('InputfieldRecurringDates'); /** @var InputfieldRecurringDates $inputfield */
        return $inputfield;
    }

    /**
     * Return a blank ready-to-populate value
     *
     * @param Page $page
     * @param Field $field
     * @return OccurrenceArray
     *
     */
    public function getBlankValue(Page $page, Field $field) {
        return new OccurrenceArray();
    }


    /**
     * Given a value, make it clean and of the correct type for storage within a Page
     *
     * @param Page $page
     * @param Field $field
     * @param EventArray $value
     * @return mixed
     *
     */
    public function sanitizeValue(Page $page, Field $field, $value) {
        // if given an invalid value, return a valid blank value
        return $value;
    }

    /*public function ___savePageField(Page $page, Field $field) {
        parent::___savePageField($page, $field);

    }*/
    protected function getRecurringDatesTable()
    {
        $field_name = $this->getAttribute('name');
        return "field_{$field_name}_dates";
    }



    /**
     * Given a raw value from DB (arrays), return the value as it would appear in a Page object (EventArray)
     *
     * @param Page $page
     * @param Field $field
     * @param array $value
     //* @return EventArray
     *
     */
    public function ___wakeupValue(Page $page, Field $field, $value) {

        // start a blank value to be populated
        $occurrences = $this->getBlankValue($page, $field);

        // if we were given a blank value, then we've got nothing to do: just return a blank EventArray
        if(empty($value) || !is_array($value)) return $occurrences;

        // create new Event objects from each item in the array
        foreach($value as $v) {
            $occurrence = new Occurrence();
            $occurrence->date = $v['data']; // note we're converting 'data' to 'date'
            $occurrence->excluded = $v['excluded'] ? true : false;
            $occurrence->resetTrackChanges();
            $occurrences->add($occurrence);
        }

        // tell it to start tracking changes from this point forward
        $occurrences->resetTrackChanges();

        return $occurrences;
    }

    /**
     * Given an EventArray value, convert the value back to an array for storage in DB
     *
     * @param Page $page
     * @param Field $field
     * @param array $value
     * @return array
     *
     */
    public function ___sleepValue(Page $page, Field $field, $value) {

        $sleepValue = array();


        if(!$value instanceof OccurrenceArray) return $sleepValue;
        // make the events sort by date ascending
        $value->sort('date');

        // convert each Event to an array within sleepValue
        foreach($value as $occurrence) {
            // if no date specified then skip it
            if(!$occurrence->date) continue;

            // if event is formatted, fail, we we don't want entity-encoded text in DB
            if($occurrence->formatted) throw new WireException('Formatted events cannot be saved');
            $sleepValue[] = array(
              'data' => $occurrence->date, // note: 'date' is becoming 'data' (with an 'a')
              'excluded' => $occurrence->excluded
            );
        }
        return $sleepValue;
    }

    /**
     * Format a value for front-end output
     *
     * This is the same as a regular value except that it is a cloned copy with
     * the “title” subfields entity encoded for output in markup.
     *
     * @param Page $page
     * @param Field $field
     * @param EventArray $value
     * @return EventArray
     *
     */
    public function ___formatValue(Page $page, Field $field, $value) {
        // make a new copy with formatted events (i.e. entity-encoded titles)
        return $value;
    }

    /**
     * Render a markup string of the value (optional for Fieldtypes to implement)
     *
     * @param Page $page
     * @param Field $field
     * @param EventArray $value
     * @param string $property Property to render or omit for all
     * @return string|MarkupFieldtype
     *
     */

    public function ___markupValue(Page $page, Field $field, $value = null, $property = '') {
        if(!$value instanceof RecurrentD) $value = $page->get($field->name);
        if(!$value instanceof EventArray || !$value->count()) return '';
        $a = [];
        foreach($value as $event) {
            if($property) {
                $a[] = $this->sanitizer->entities1($event->get($property));
            } else {
                $a[] = $this->sanitizer->entities1("$event->date");
            }
        }
        return "<ul><li>" . implode("</li><li>", $a) . "</li></ul>";
    }

    public function getMonths(){
        $months = [];
        for ($m=1; $m<=12; $m++) {
            $months[] = date('F', mktime(0,0,0,$m, 1, date('Y')));
        }
        //bd($months);
        return $months;
    }

    /**
     * Method called when the field is database-queried from a $pages->find() selector
     *
     * @param DatabaseQuerySelect|PageFinderDatabaseQuerySelect
     * @param string $table
     * @param string $subfield
     * @param string $operator
     * @param string $value
     * @return PageFinderDatabaseQuerySelect
     *
     */
    /*
    public function getMatchQuery($query, $table, $subfield, $operator, $value) {

        if($subfield == 'date') {
            // If searching 'date' then assume our default (data) field
            $subfield = 'data';
        }

        if($subfield === 'data') {
            // if searching data, make sure it is in the correct 'date' format
            $value = wireDate('Y-m-d', $value);

        } else if($subfield === 'title') {
            // use fulltext search features when searching title
            $finder = new DatabaseQuerySelectFulltext($query);
            $finder->match($table, $subfield, $operator, $value);
            return $query;
        }

        return parent::getMatchQuery($query, $table, $subfield, $operator, $value);
    }
    */

    /**
     * Return array with information about what properties and operators can be used with this field
     *
     * This is what is used when finding pages like with Lister/ListerPro, etc.
     * ProcessWire’s default generally gets this right so we often don’t have to implement this method.
     * In this case, we are just having it show the correct label for “Date”.
     *
     * @param Field $field
     * @param array $data Array of extra data, when/if needed
     * @return array
     *
     */
    /*public function ___getSelectorInfo(Field $field, array $data = array()) {
        $info = parent::___getSelectorInfo($field, $data);
        $info['subfields']['data']['label'] = $this->_('Date');
        return $info;
    }*/

    public function ___loadPageField(Page $page, Field $field)
    {   //bd($field);
        //$field->set('paginationLimit', 2);
        $input = $this->wire()->input;

        $value =  parent::___loadPageField($page, $field); // TODO: Change the autogenerated stub
        bd($value);
        return $value;
    }

}
